{"data":{"mdx":{"id":"cc96704f-73d2-5f2d-aca4-95fe285c0b5b","frontmatter":{"title":"Reshaping git history","date":"April 19, 2019"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2019-04-19T00:00:00.000Z\",\n  \"title\": \"Reshaping git history\",\n  \"published\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Why does it matter?\"), mdx(\"p\", null, \"I personally like my commit history to look neat and polished, clearly showcasing what has been accomplished. After all, one solid commit instead of few related but scattered, partial ones is certainly better in terms of readability, portability and clarity. In this post I'm not going to dig into why maintaining clean history is beneficial, it's rather meant as a practical overview of several \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase\"), \" actions allowing for history grooming. Suffice to say it especially makes sense in collaboration environment. When flying solo, however, you might not really care about how project history looks like.\"), mdx(\"h1\", null, \"Possible cases\"), mdx(\"p\", null, \"You start working on some feature, you've made several commits, it's almost completed. But suddenly requirements change (happens once in a blue moon, right?), and you have to introduce changes. You tack new commits onto the existing chain. But what if you wanted to unite related changes before sharing your work?\"), mdx(\"p\", null, \"Or consider the following situation. Idea sparks in your mind and you get down to implementing it. In the heat of development, you run up several crude commits in a short succession. You usually strive to keep it focused, but you hands were on fire, you didn't want to be bogged down so you temporarily turned a blind eye on formalities. How do you put things in order now that the sudden drive has subsided?\"), mdx(\"p\", null, \"Another common scenario is back and forth during PR's review rounds. There could be several takes before you get it right. Once the review is over, it's time to stick commits produced on the fly where they initially belong. Let's explore how it could be accomplished!\"), mdx(\"h1\", null, \"Turn up the bass and rebase\"), mdx(\"p\", null, \"Git offers a robust way to mould commit history via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --interactive (or -i)\"), \" command. It offers more than ten actions and helpfully all of them, along with succinct explanations, are always outlined below the list of commits which are rebased. For our purposes, we'll be considering the following subset:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"edit\"), \" - allows for amending commit at hand;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"squash\"), \" - combine commit in question with the one above and choose which commit message to use;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fixup\"), \" - has same effect as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"squash\"), \", but uses target commit's log message;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"drop\"), \" - erase commit.\")), mdx(\"p\", null, \"To actually kick off the process we need to supply an SHA hash of the commit which comes right before the point where we'd like to start rebasing:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase -i <after_this_commit>\")), mdx(\"p\", null, \"=====\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note:\")), mdx(\"h1\", null, \"While rebasing you are in so called \", \"[detached HEAD state][https://git-scm.com/docs/git-checkout#_detached_head]\", \", similar to when checking out older history records. This simply means that all new commits made while at it will be lost (garbage collector routinely removes non-referenced objects) unless you create an explicit reference. Make sure to either branch off or attach a tag so you have a way of returning to your commits once rebase is over.\"), mdx(\"p\", null, \"As a result, git opens up an editor within the terminal window and presents a list of selected commits (bear in mind that merge commits are ignored).\"), mdx(\"p\", null, \"=====\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Pro tip:\"), \"\\nYou don't have to always use hash. If you know upfront that you want to reach third-to-last commit, tip of the branch (HEAD pointer) could be used as the reference:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase -i HEAD~3\")), mdx(\"h1\", null, mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"HEAD~15\"), \" would output 15 latest commits, and so on.\"), mdx(\"p\", null, \"The list will resemble the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\npick bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pick\"), \" is the default action indicating our intention to keep the commit. If we wanted to manipulate any of the records, we'd replace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pick\"), \" with desired action. Simply reordering items on the list is also an option.\"), mdx(\"h2\", null, \"Editing\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\nedit bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\n\")), mdx(\"p\", null, \"Git follows the list top to bottom and executes actions sequentially. In this example, when it reaches \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bass1st\"), \", the process will pause so you can introduce changes. Once done, add edits to the staging area, invoke \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --amend\"), \" to fold them in and resume the process using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --continue\"), \".\\nIn rare cases you need to split the commit. This could be achieved by unstaging all files via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git reset\"), \" and then forming tinier commits as required.\"), mdx(\"p\", null, \"=====\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note:\")), mdx(\"h1\", null, \"Sometimes things get messed up. Fortunately, it's always possible to cancel the ongoing rebase completely - just type \", mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"git rebase --abort\"), \" and everything will be restored to the prior state.\"), mdx(\"h2\", null, \"Squashing and fixups\"), mdx(\"p\", null, \"Say we committed something which fundamentally belongs to the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a1rt1m3\"), \" commit:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\npick bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\npick jazz13r new changes\\n\")), mdx(\"p\", null, \"There are two options to meld \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jazz13r\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a1rt1m3\"), \". First would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"squash\"), \", which allows for choosing which commit message to apply in the end. Second one would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fixup\"), \", which acts identically but doesn't let you pick and uses target commit's message instead.\"), mdx(\"p\", null, \"With any of these commands, however, the general idea is to place accessary commit (or commits) right below the target commit:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\nfixup jazz13r new changes\\npick bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\n\")), mdx(\"p\", null, \"If there are any conflicting changes, git automatically resolves them in favour of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fixup/squash\"), \" commits.\"), mdx(\"p\", null, \"Picking an action and reordering could be done automatically if we follow these steps:\"), mdx(\"p\", null, \"1) Commit changes which are meant to be folded into another set using \", \"[special option][https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupltcommitgt]\", \" and specifying the target:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --squash (or --fixup) <commit_to_modify>\")), mdx(\"p\", null, \"In our scenario, command would've looked like so:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --fixup a1rt1m3\")), mdx(\"p\", null, \"This produces otherwise an ordinary commit, the only difference being its subject line which is comprised of target commit's message prefixed with the action we defined earlier:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\npick bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\npick jazz13r fixup! third-to-last commit's summary\\n\")), mdx(\"p\", null, \"2) Start rebasing with an \", \"[additional flag][https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---autosquash]\", \":\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase -i --autosquash HEAD~4\")), mdx(\"p\", null, \"Git will pre-scan titles in the list and arrange everything for you:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit's summary\\nfixup jazz13r fixup! third-to-last commit's summary\\npick bass1st second-to-last commit's summary\\npick cr0wbar last commit's summary\\n\")), mdx(\"p\", null, \"=====\"), mdx(\"h2\", null, \"Deleting\"), mdx(\"p\", null, \"Deleting is trivial. Either apply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drop\"), \" action, or simply erase the line.\"), mdx(\"h1\", null, \"Proceed with caution\"), mdx(\"p\", null, \"Rebasing (or any other method of rewriting for that matter) a branch which others have used as a basis for their work is a terrible idea. It will likely cause major nuisance and provoke issues. Even if you haven't changed anything during rebase, every commit touched by the process will have its hash recalculated and everyone downstream at the very least will be forced to refetch in order to avoid complications. \", \"[In the worst case][https://git-scm.com/docs/git-rebase#_the_hard_case]\", \", they'll have to manually fix their history - and this is by no means an enjoyable pastime. Something to always keep in mind - never amend shared work history.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"cc96704f-73d2-5f2d-aca4-95fe285c0b5b"}}