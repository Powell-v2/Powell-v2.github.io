{"data":{"mdx":{"id":"cc96704f-73d2-5f2d-aca4-95fe285c0b5b","frontmatter":{"title":"Reshaping Git History","date":"April 19, 2019"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2019-04-19T00:00:00.000Z\",\n  \"title\": \"Reshaping Git History\",\n  \"published\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Rebase to the occasion\"), mdx(\"p\", null, \"It's all too familiar - you start working on some feature \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"locally\"), \", you've made several commits, it's almost completed. But suddenly requirements change (happens once in a blue moon, right?), and you have to introduce changes. You tack new commits onto the existing chain. But what if you wanted to unite related changes in an effort to improve readability, portability and clarity before sharing your work with others?\"), mdx(\"p\", null, \"Or consider the following situation. Idea sparks in your mind and you get down to implementing it. In the heat of development, you run up several crude commits in a short succession. You usually strive to keep it focused, but you hands were on fire, you didn't want to be bogged down so you temporarily turned a blind eye on formalities. How do you put things in order now that the sudden drive has subsided?\"), mdx(\"p\", null, \"Another common scenario is back and forth during PR's review rounds. There could be several takes before you get it right. Once the review is over, it's time to stick changes produced on the fly where they initially belong.\"), mdx(\"p\", null, \"Git grants plenty of freedom when a need to revise \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"local\"), \" history arises. Commits could be rearranged, altered, split apart, squashed together or wiped out entirely. Surprisingly enough, there is no dedicated tool for modifying history directly! \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --amend\"), \" might come to your mind as it helps with altering the most recent commit. However, if you need to reach deeper into history, you have to resort to interactive rebase. The trick is to take a series of commits and rebase them onto their original HEAD instead of another one.\"), mdx(\"p\", null, \"I personally like my commit history to come across as neat and polished, clearly showcasing what has been accomplished. But in this post I'm not going to dig into why maintaining clean history is beneficial. It's rather meant as a practical overview of several \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --interactive\"), \" actions allowing for history grooming. Suffice to say it especially makes sense in collaboration environment. When working on some local project which isn't destined to see the light of the day you might not really care how its history looks.\"), mdx(\"h2\", null, \"Turn up the bass and rebase\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --interactive (or just -i)\"), \" command is a robust way to mould commit history.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"It offers more than ten various actions and rather helpfully all of them, along with succinct explanations, are always outlined below the list of commits which are being rebased. For our purposes, we'll be considering the following subset:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"edit\"), \" - allows for amending commit in question;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"squash\"), \" - combine commit at hand with the one directly above and choose which commit message to use;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fixup\"), \" - has the same effect as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"squash\"), \", but uses target commit's log message;\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"drop\"), \" - erase commit.\")), mdx(\"p\", null, \"To actually kick off the process we need to supply an SHA hash of the commit which comes right before the point where we'd like to start rebasing:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git rebase -i <after_this_commit>\\n\")), mdx(\"p\", null, \"You don't have to always use hash. If you know upfront that you want to reach third-to-last commit, tip of the branch (HEAD pointer) could be used as a reference:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"git rebase -i HEAD~3\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HEAD~15\"), \" would output 15 latest commits, and so on.\"), mdx(\"p\", null, \"As a result, Git opens up an editor within the terminal window and presents a list of selected commits (we'll stick with the last three) which will resemble the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\npick bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\n\")), mdx(\"p\", null, \"Compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git log\"), \" output, the chronological order is reversed - the oldest change appears at the top here. If we just save the buffer without touching anything, Git will follow the listing downward and execute actions sequentially. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pick\"), \" is the default one indicating our intention to keep the commit. If we wanted to manipulate any of the records, we'd replace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pick\"), \" with desired action. Simply reordering items on the list is also an option if that's what you are after.\"), mdx(\"h3\", null, \"Editing\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\nedit bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\n\")), mdx(\"p\", null, \"In this scenario, when Git reaches \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bass1st\"), \", it will pause and give you an opportunity to introduce changes. Once done, toss edits into the staging area, invoke \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --amend\"), \" to fold them in and resume the process using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --continue\"), \".\"), mdx(\"p\", null, \"Sometimes it might make sense to split one large commit apart. In order to achieve that, unstage all associated files via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git reset HEAD~\"), \" (which effectively undoes the commit) and form tinier commits as required.\"), mdx(\"p\", null, \"It's worth noting that when Git stops and gives you a chance to edit a commit you'll find yourself in so called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://git-scm.com/docs/git-checkout#_detached_head\"\n  }), \"detached HEAD state\"), \". It usually implies that all new commits will be lost unless you create an explicit reference (new branch or tag) as garbage collector routinely removes non-referenced objects. However, you don't have to worry about that while rebasing since Git already knows that we'd like to retain any changes as part of the process.\"), mdx(\"p\", null, \"Finally, if you misstepped and things got messed up - don't fret! It's always possible to cancel out an ongoing rebase and restore everything to the prior state by executing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase --abort\"), \".\"), mdx(\"h3\", null, \"Squashing and fixups\"), mdx(\"p\", null, \"Say we committed something which fundamentally belongs to the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a1rt1m3\"), \" commit:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\npick bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\npick jazz13r new changes\\n\")), mdx(\"p\", null, \"There are two options to meld \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jazz13r\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a1rt1m3\"), \". First would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"squash\"), \", which allows for choosing which commit message to apply in the end. Second one would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fixup\"), \", which acts identically but doesn't let you pick and uses target commit's message instead.\"), mdx(\"p\", null, \"With any of these commands, however, the general idea is to place accessary commit (or commits) right below the target commit:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\nfixup jazz13r new changes\\npick bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\n\")), mdx(\"p\", null, \"Picking an action and reordering could be done automatically if we follow these steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Commit changes which are meant to be folded into another set using \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupltcommitgt\"\n  }), \"special option\"), \" and specifying the target:\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --squash (or --fixup) <commit_to_modify>\")), mdx(\"p\", null, \"In our scenario, command would've looked like that:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git commit --fixup a1rt1m3\")), mdx(\"p\", null, \"It produces otherwise an ordinary commit, the only difference being its subject line which is comprised of target commit's message prefixed with the action we defined earlier:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\npick bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\npick jazz13r fixup! third-to-last commit summary\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start rebasing with an \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---autosquash\"\n  }), \"additional flag\"), \":\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase -i --autosquash HEAD~4\")), mdx(\"p\", null, \"Git will pre-scan records and rearrange the list for you:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"pick a1rt1m3 third-to-last commit summary\\nfixup jazz13r fixup! third-to-last commit summary\\npick bass1st second-to-last commit summary\\npick cr0wbar last commit summary\\n\")), mdx(\"h3\", null, \"Deleting\"), mdx(\"p\", null, \"Deleting is trivial. Either apply \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drop\"), \" action, or simply erase the line.\"), mdx(\"h2\", null, \"Proceed with caution\"), mdx(\"p\", null, \"Rebasing (or any other method of rewriting for that matter) a branch which others have used as a basis for their work is a terrible idea. It will likely cause major nuisance and provoke issues. Even if you haven't changed anything during rebase, every commit touched by the process will have its hash recalculated and everyone downstream at the very least will be forced to refetch in order to avoid complications. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://git-scm.com/docs/git-rebase#_the_hard_case\"\n  }), \"In the worst case\"), \", they'll have to manually fix their history and this is by no means an enjoyable pastime. Bottom line - never ever amend shared work history and only push your commits to the remote when you are truly happy with the result.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"id":"cc96704f-73d2-5f2d-aca4-95fe285c0b5b"}}